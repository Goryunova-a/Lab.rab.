# Тема 9. Концепции и принципы ООП
Отчет по Теме #9 выполнила:
- Горюнова Алина Алексеевна
- ИВТ-22-1

| Задание | Лаб_раб | Сам_раб|
| ------ | ------ | ------|
| Задание 1 | + | + |
| Задание 2 | + | 
| Задание 3 | + | 
| Задание 4 | + | 
| Задание 5 | + | 


знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.


Лабораторные задания:	

1) Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию_init_(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.

```python
class Ivan:
    __slots__ = ['name']
    
    def __init__(self,name):
        if name == 'Иван':
            self.name = f" Да, я {name}"
        else:
            self.name = f" Я не {name}, а Иван"
person1 = Ivan('Алексей')
person2 = Ivan('Иван')
print(person1.name)
print(person2.name)
person2.surname = 'Петров'
```
![Меню](https://github.com/Goryunova-a/Lab.rab./blob/main/pic9/pic1.png)
- Данная программа корректно обрабатывает ввод имен и выводит сообщения в зависимости от того, угадано ли имя.


2) Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором
будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.
```python
class Icecream:
    def __init__(self, ingredient=None):
        if isinstance(ingredient, str):
            self.ingredient = ingredient
        else:
            self.ingredient = None
    def composition(self):
        if self.ingredient:
            print(f"Мороженное с {self.ingredient}")
        else:
            print('Oбычное мороженно')
icecream = Icecream()
icecream.composition()
icecream = Icecream('шоколадом')
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```
![Меню](https://github.com/Goryunova-a/Lab.rab./blob/main/pic9/pic2.png)
- В данной программе с помощью функции реализуется определение наличия или отсутсвия топпинга в мороженом

3) Петя - начинающий программист и на занятиях ему сказали реализовать икапсу...что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу... что-то - это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают.
Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.
```python
class MyClass:
    def __init__(self, value):
        self._value = value
        
    def set_value(self, value):
        self._value = value
        
    def get_value(self):
        return self._value
    
    def del_value(self):
        del self._value
        
    value = property(get_value, set_value, del_value, "Свойство value")
    
obj = MyClass(42)
print(obj.get_value())
obj.set_value(45)
print(obj.get_value())
obj.set_value(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())
```
![Меню](https://github.com/Goryunova-a/Lab.rab./blob/main/pic9/pic3.png)
- Данная программа показывает как работает класс не просто инкапсуляцией, а классом с сеттером, геттером и деструктором.
- Метод класса, который служит конструктором, должен называться init. Здесь он назван просто init, что является ошибкой.
Опечатка в методе get_value. В данном методе вместо _value должно быть value, так как именно это имя используется в сигнатуре свойства.

4) Вам прекрасно известно, что кошки И собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи "наследования” объяснить компьютеру что кошки и собаки млекопитающие. 
```python
class Mammal:
    className = 'Mammal'
class Dog(Mammal):
    species = 'canine'
    sounds ='wow'
class Cat(Mammal):
    species = 'feline'
    sounds = 'meow'
dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Cat is{cat.className}, but they say {cat.sounds}")
```
![Меню](https://github.com/Goryunova-a/Lab.rab./blob/main/pic9/pic4.png)
- Данная программа показывает работу "наследования" классов


5) На разных языках здороваются по-разному, суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются.
Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.
```python
class Russian:
    @staticmethod
    def greeting():
        print("Привет")
class English:
    @staticmethod
    def greeting():
        print("Hello")
def greet(language):
    language.greeting()
ivan = Russian()
greet(ivan)
john = English()
greet(john)
```
![Меню](https://github.com/Goryunova-a/Lab.rab./blob/main/pic9/pic5.png)
- Данная программа помогаяет наглядно увидеть, как работает декоратор @staticmethod,также показан пример полиморфизма.

Самостоятельное задание:

№1
Класс Tomato:
1) Создайте класс Tomato
2) Создайте статическое свойство states, которое будет содержать все стадии созревания помидора
3) Создайте метод _init_(), внутри которого будут определены два динамических свойства:_index (передается параметром) и_state
(принимает первое значение из словаря states). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
4) Создайте метод grow(), который будет переводить томат на
следующую стадию созревания
5) Создайте метод is_ripe(), который будет проверять, что томат созрел

Класс TomatoBush:
1) Создайте класс TomatoBush
2) Определите метод_init__(), который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса Tomato. Данный список будет храниться внутри динамического свойства tomatoes
3) Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания
4) Создайте метод all_are_ripe(), который будет возвращать True, если
все томаты из списка стали спелыми.

5) Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая

Класс Gardener:
1) Создайте класс Gardener
2) Создайте метод_init_(), внутри которого будут определены два динамических свойства: name (передается параметром, является публичным) и _plant (принимает объект класса TomatoBush). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
3) Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым
4) Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
5) Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству

Тесты:
1) Вызовите справку по садоводству
2) Создайте объекты классов TomatoBush и Gardener
3) Используя объект класса Gardener, поухаживайте за кустом с помидорами
4) Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними
5) Соберите урожай
```python
#класс томат
class Tomato:
    states = {0: 'посажен', 1: 'зацветает', 2: 'позеленел', 3: 'созрел'}

    def __init__(self, index):#конструктор класса, который принимает индекс плода
        self._index = index
        self._state = 0

    def grow(self):#метод роста томата
        if self._state < 3:
            self._state += 1

    def is_ripe(self):#метод, проверяющий зрелость плода. возвращает True, если он созрел
        if self._state == 3:
            return True
        return False


class TomatoBush:#класс Куст томатов
    def __init__(self, num):#конструкотор класса, котрый принимает количество томатов на кусте
        self.tomatoes = [Tomato(i) for i in range(num)]

    def grow_all(self):#метод роста всех плодов на кусте
        for tomato in self.tomatoes:
            tomato.grow()

    def all_are_ripe(self): #метод, котрый возврвщает True, когда все томаты созрели
        return all(tomato.is_ripe() for tomato in self.tomatoes)

    def give_away_all(self):
        self.tomatoes = []
        
class Gardener: #класс Садовник
    def __init__(self, name, plant):#конструктор класса, который принимает имя самого садовника и растение, которое он выращивает
        self.name = name
        self._plant = plant

    def work(self):#метод работы садовника, вызывается, если есть плоды на кусте
        if self._plant.tomatoes:
            self._plant.grow_all()

    def harvest(self):# метод сбора урожая, прооверяет зрелость, если не созрели, будет предупреждение
        if self._plant.all_are_ripe():
            self._plant.give_away_all()
            print(f"Садовник {self.name} собрал урожай")
        else:
            print(f"Садовнику {self.name} нельзясобирать урожай, не все томаты созрели.")
#статистический метод, в котором находится информация по уходу за растением
    @staticmethod
    def knowledge_base():#статистический метод
        print("Справка по садоводству:")
        print("- Нужно регулярно поливать кусты и убирать сорняки и траву, которые мешабт росту томатов.")
        print("- Томаты можно собирать только тогда, когда они покраснеют.")
        print("- Собирать урожай нужно аккуратно, чтобы на том же кусте могли созреть ещё томаты.")

Gardener.knowledge_base() #вызов справки по садоводству
#создание объектов классов TomatoBush и Gardener 
bush = TomatoBush(10)
gardener = Gardener("Василий", bush)
#ухаживаем за кустом
for _ in range(3):
    gardener.work()
#робуем собрать урожай, пока томаты не дозрели
gardener.harvest()

while not bush.all_are_ripe():
    gardener.work()
    gardener.harvest()

gardener.harvest()
#собираем урожай
```
![Меню](https://github.com/Goryunova-a/Lab.rab./blob/main/pic9/pic6_1.png)
- Я разобралась в основах создания классов и объектов в Python, изучила работу с методами класса и конструкторами. Применив принципы ООП на практике, я поняла их ипользование и значимость при разработке программных систем.

Общий вывод


В процессе выполнения этой лабораторной работы были изучены основные понятия объектно-ориентированного программирования, включая инкапсуляцию, наследование и полиморфизм. Данные принципы помогают разрабатывать гибкий и масштабируемый код, который удобно обслуживать и изменять.
